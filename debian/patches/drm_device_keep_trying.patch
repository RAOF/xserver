From fe5802680b5ecf5ecef55b839f2f555882207d41 Mon Sep 17 00:00:00 2001
From: Bryce Harrington <bryce@canonical.com>
Date: Wed, 13 Feb 2013 11:39:34 -0800
Subject: [PATCH] If drm device couldn't be opened, keep trying for a sec.

The kernel returns EACCES or EAGAIN on drm open when the drm device is
currently unavailable, such as if it is in use by another process
(e.g. plymouth), or hasn't finished initializing (e.g. on a really fast
SSD).  Check for errors when trying to open the device, and continue
retrying for a short period before giving up.

Fixes: https://bugs.launchpad.net/ubuntu/+source/xorg-server/+bug/982889

Signed-off-by: Bryce Harrington <bryce@canonical.com>
---
 hw/xfree86/os-support/linux/lnx_platform.c |   29 +++++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

--- a/config/udev.c
+++ b/config/udev.c
@@ -98,7 +98,7 @@
         if (strncmp(sysname, "card", 4) != 0)
             return;
 
-        LogMessage(X_INFO, "config/udev: Adding drm device (%s)\n", path);
+        LogMessage(X_INFO, "config/udev: Adding drm device (%s) %s %s\n", path, sysname, syspath);
 
         config_udev_odev_setup_attribs(path, syspath, NewGPUDeviceRequest);
         return;
@@ -267,7 +267,7 @@
 
         if (strncmp(sysname,"card", 4) != 0)
             return;
-        ErrorF("removing GPU device %s %d\n", syspath, path);
+        ErrorF("removing GPU device %s %s\n", syspath, path);
         if (!path)
             return;
 
@@ -420,11 +420,23 @@
 #ifdef CONFIG_UDEV_KMS
 
 static Bool
+get_pci_busid(const char *in, char *pci_str)
+{
+    int ret, domain, bus, dev, func;
+    ret = sscanf(in, "/%04x:%02x:%02x.%d/drm/card%*d", &domain, &bus, &dev, &func);
+    if (ret != 4)
+        return FALSE;
+    sprintf(pci_str, "pci:%04x:%02x:%02x.%d", domain, bus, dev, func);
+    return TRUE;
+}
+
+static Bool
 config_udev_odev_setup_attribs(const char *path, const char *syspath,
                                config_odev_probe_proc_ptr probe_callback)
 {
     struct OdevAttributes *attribs = config_odev_allocate_attribute_list();
     int ret;
+    const char *platform;
 
     if (!attribs)
         return FALSE;
@@ -437,6 +449,32 @@
     if (ret == FALSE)
         goto fail;
 
+    if (strstr(syspath, "/devices/pci")) {
+        char pci_str[17];
+        const char *end = strstr(syspath, "/drm/card");
+        if (strstr(syspath, "/usb"))
+            ret = config_odev_add_attribute(attribs, ODEV_ATTRIB_BUSID, "");
+        else if (get_pci_busid(end - 13, pci_str))
+            ret = config_odev_add_attribute(attribs, ODEV_ATTRIB_BUSID, pci_str);
+    } else if ((platform = strstr(syspath, "/devices/platform/"))) {
+        const char *end;
+        platform += 18;
+        end = strchr(platform, '.');
+        if (end) {
+            char *busid;
+            ret = asprintf(&busid, "platform:%.*s:%02li",
+                           (int)(end - platform), platform, strtol(end + 1, NULL, 10));
+            if (ret >= 0) {
+                ret = config_odev_add_attribute(attribs, ODEV_ATTRIB_BUSID, busid);
+                free(busid);
+            }
+            else
+                ret = TRUE;
+        }
+    }
+    if (ret == FALSE)
+        goto fail;
+
     /* ownership of attribs is passed to probe layer */
     probe_callback(attribs);
     return TRUE;
--- a/hw/xfree86/os-support/linux/lnx_platform.c
+++ b/hw/xfree86/os-support/linux/lnx_platform.c
@@ -17,8 +17,8 @@
 
 #include "hotplug.h"
 
-static Bool
-get_drm_info(struct OdevAttributes *attribs, char *path)
+static void
+set_drm_info(const char *path)
 {
     drmSetVersion sv;
     char *buf;
@@ -26,25 +26,23 @@
 
     fd = open(path, O_RDWR, O_CLOEXEC);
     if (fd == -1)
-        return FALSE;
+        return;
 
     sv.drm_di_major = 1;
     sv.drm_di_minor = 4;
     sv.drm_dd_major = -1;       /* Don't care */
     sv.drm_dd_minor = -1;       /* Don't care */
     if (drmSetInterfaceVersion(fd, &sv)) {
-        ErrorF("setversion 1.4 failed\n");
-        return FALSE;
+        ErrorF("setversion 1.4 failed on %s: %m\n", path);
+        close(fd);
+        return;
     }
 
-    xf86_add_platform_device(attribs);
-
     buf = drmGetBusid(fd);
+    close(fd);
     xf86_add_platform_device_attrib(xf86_num_platform_devices - 1,
                                     ODEV_ATTRIB_BUSID, buf);
     drmFreeBusid(buf);
-    close(fd);
-    return TRUE;
 }
 
 Bool
@@ -93,14 +91,15 @@
 {
     struct OdevAttribute *attrib;
     int i;
-    char *path = NULL;
-    Bool ret;
+    const char *path = NULL, *busid = NULL, *syspath = NULL;
 
     xorg_list_for_each_entry(attrib, &attribs->list, member) {
-        if (attrib->attrib_id == ODEV_ATTRIB_PATH) {
+        if (attrib->attrib_id == ODEV_ATTRIB_PATH)
             path = attrib->attrib_name;
-            break;
-        }
+        else if (attrib->attrib_id == ODEV_ATTRIB_SYSPATH)
+            syspath = attrib->attrib_name;
+        else if (attrib->attrib_id == ODEV_ATTRIB_BUSID)
+            busid = attrib->attrib_name;
     }
     if (!path)
         goto out_free;
@@ -119,10 +118,11 @@
     LogMessage(X_INFO, "config/udev: Adding drm device (%s)\n",
                path);
 
-    ret = get_drm_info(attribs, path);
-    if (ret == FALSE)
-        goto out_free;
-
+    xf86_add_platform_device(attribs);
+    if (!busid) {
+        LogMessage(X_WARNING, "Could not extract busid from syspath %s, attempting drm probe\n", syspath);
+        set_drm_info(path);
+    }
     return;
 
 out_free:
