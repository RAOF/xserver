Index: xorg-server/include/protocol-versions.h
===================================================================
--- xorg-server.orig/include/protocol-versions.h	2012-03-07 22:24:45.540697115 +1100
+++ xorg-server/include/protocol-versions.h	2012-03-08 07:40:35.472111389 +1100
@@ -122,7 +122,7 @@
 #define SERVER_XF86VIDMODE_MINOR_VERSION	2
 
 /* Fixes */
-#define SERVER_XFIXES_MAJOR_VERSION		5
+#define SERVER_XFIXES_MAJOR_VERSION		6
 #define SERVER_XFIXES_MINOR_VERSION		0
 
 /* X Input */
Index: xorg-server/xfixes/cursor.c
===================================================================
--- xorg-server.orig/xfixes/cursor.c	2012-03-07 22:24:45.580697117 +1100
+++ xorg-server/xfixes/cursor.c	2012-03-08 11:00:53.155469738 +1100
@@ -61,6 +61,7 @@
 static RESTYPE		CursorHideCountType;
 static RESTYPE		CursorWindowType;
 RESTYPE			PointerBarrierType;
+static RESTYPE		PointerBarrierClientType;
 static CursorPtr	CursorCurrent[MAXDEVICES];
 
 static DevPrivateKeyRec CursorScreenPrivateKeyRec;
@@ -119,6 +120,11 @@
     struct list entry;
 };
 
+/**
+ * Pick up unclamped (x,y) coordinates from dix/getevents
+ */
+extern int unclamped_prex, unclamped_prey;
+
 /*
  * Wrap DisplayCursor to catch cursor change events
  */
@@ -129,6 +135,7 @@
     ConstrainCursorHarderProcPtr ConstrainCursorHarder;
     CursorHideCountPtr          pCursorHideCounts;
     struct list                 barriers;
+    struct list                 barrierClients;
 } CursorScreenRec, *CursorScreenPtr;
 
 #define GetCursorScreen(s) ((CursorScreenPtr)dixLookupPrivate(&(s)->devPrivates, CursorScreenPrivateKey))
@@ -1118,7 +1125,8 @@
 
     /* Algorithm below doesn't handle edge cases well, hence the extra
      * checks. */
-    if (barrier_is_vertical(barrier)) {
+    if (barrier_is_vertical(barrier) &&
+	(dir & (BarrierPositiveX | BarrierNegativeX))) {
 	/* handle immediate barrier adjacency, moving away */
 	if (dir & BarrierPositiveX && x1 == barrier->x1)
 	    return FALSE;
@@ -1129,7 +1137,8 @@
 	    *distance = 0;
 	    return TRUE;
 	}
-    } else {
+    } else if (barrier_is_horizontal(barrier) &&
+		(dir & (BarrierPositiveY | BarrierNegativeY))){
 	/* handle immediate barrier adjacency, moving away */
 	if (dir & BarrierPositiveY && y1 == barrier->y1)
 	    return FALSE;
@@ -1231,6 +1240,127 @@
     }
 }
 
+/*
+ * ConstrainCursorHarder is called from the SIGIO context.
+ * This means we cannot safely send a client event from anything in
+ * CursorConstrainCursorHarder's callgraph.
+ *
+ * Allocate a set of WorkQueue items to use.
+ */
+
+struct BarrierEventStore {
+    WorkQueueRec wq_item;
+    xXFixesBarrierNotifyEvent ev;
+    Bool in_use;
+};
+
+/* Let's guess that 100 events is enough of a buffer. */
+#define BARRIER_EVENT_QUEUE_SIZE 100
+struct BarrierEventStore barrierEventQueue[BARRIER_EVENT_QUEUE_SIZE];
+
+static void
+CursorWorkQueueDestroyProc (WorkQueuePtr this)
+{
+    struct BarrierEventStore *store;
+    store = container_of (this, struct BarrierEventStore, wq_item);
+
+    store->in_use = FALSE;
+}
+
+static Bool
+CursorSendBarrierEvent (ClientPtr client, pointer eventStore)
+{
+    struct BarrierEventStore *store = (struct BarrierEventStore *)eventStore;
+    WriteEventsToClient (client, 1, (xEvent *)&store->ev);
+
+    return TRUE;
+}
+
+static struct BarrierEventStore *
+CursorFindFreeEventStore (void)
+{
+    for (int i = 0; i < BARRIER_EVENT_QUEUE_SIZE; ++i) {
+	if (!barrierEventQueue[i].in_use) {
+	    return &barrierEventQueue[i];
+	}
+    }
+    return NULL;
+}
+
+static void
+QueueBarrierEvent(CursorScreenPtr cs, struct PointerBarrier *barrier,
+		  int x, int y, int velocity, Bool threshold_exceeded)
+{
+    PointerBarrierEventClientPtr client;
+    struct BarrierEventStore *store;
+    list_for_each_entry(client, &cs->barrierClients, entry) {
+	store = CursorFindFreeEventStore ();
+	if (store == NULL) {
+	    ErrorF ("[xfixes] Barrier event queue full.  Dropping further events\n");
+	    return;
+	}
+
+	store->in_use = TRUE;
+
+	store->ev.type = XFixesEventBase + XFixesBarrierNotify;
+	store->ev.subtype = threshold_exceeded ? XFixesBarrierThresholdExceededNotify :
+					         XFixesBarrierHitNotify;
+	store->ev.event_id = barrier->barrierEventID;
+	store->ev.barrier = barrier->barrier;
+	store->ev.x = x;
+	store->ev.y = y;
+	store->ev.velocity = velocity;
+	store->ev.timestamp = currentTime.milliseconds;
+
+	if (client->client->swapped) {
+	    int n;
+
+	    swapl(&store->ev.event_id, n);
+	    swapl(&store->ev.barrier, n);
+	    swaps(&store->ev.x, n);
+	    swaps(&store->ev.y, n);
+	    swapl(&store->ev.velocity, n);
+	    swapl(&store->ev.timestamp, n);
+	}
+
+	store->wq_item.function = CursorSendBarrierEvent;
+	store->wq_item.client = client->client;
+	store->wq_item.closure = store;
+	store->wq_item.destroyProc = CursorWorkQueueDestroyProc;
+
+	QueueWorkItem (&store->wq_item); 
+    }
+}
+
+static void
+barrier_calculate_velocity_components (int x1, int y1, int x2, int y2,
+				       int *vel_x, int *vel_y)
+{
+    static CARD32 last_timestamp = 0;
+    CARD32 timestamp = GetTimeInMillis();
+    int dx, dy;
+    int dt = timestamp - last_timestamp;
+
+    if (last_timestamp == 0) {
+	/* Not much we can do for the first event */
+	*vel_x = 0;
+	*vel_y = 0;
+	last_timestamp = timestamp;
+	return;
+    }
+
+    /* Lets not divide by zero if we can avoid it */
+    dt = dt > 0 ? dt : 1;
+
+    dx = x2 - x1;
+    dy = y2 - y1;
+
+    *vel_x = abs(dx) * 1000.0 / dt;
+    *vel_y = abs(dy) * 1000.0 / dt;
+
+    last_timestamp = timestamp;
+}
+
 static void
 CursorConstrainCursorHarder(DeviceIntPtr dev, ScreenPtr screen, int mode, int *x, int *y)
 {
@@ -1238,12 +1368,23 @@
 
     if (!list_is_empty(&cs->barriers) && !IsFloating(dev) && mode == Relative) {
 	int ox, oy;
+	int vel_x, vel_y;
 	int dir;
 	struct PointerBarrier *nearest = NULL;
+	PointerBarrierClientPtr c;
 
 	/* where are we coming from */
 	miPointerGetPosition(dev, &ox, &oy);
 
+	/* Use the unclamped values, if available.  If not, *x, *y
+	 * will have to do.
+	 * NOTE: We should never get here with unclamped values unset.
+	 */
+	if (unclamped_prex == -1 || unclamped_prey == -1) {
+	    unclamped_prex = *x;
+	    unclamped_prey = *y;
+	}
+
 	/* How this works:
 	 * Given the origin and the movement vector, get the nearest barrier
 	 * to the origin that is blocking the movement.
@@ -1251,11 +1392,27 @@
 	 * Then, check from the clamped intersection to the original
 	 * destination, again finding the nearest barrier and clamping.
 	 */
-	dir = barrier_get_direction(ox, oy, *x, *y);
+	dir = barrier_get_direction(ox, oy, unclamped_prex, unclamped_prey);
+	barrier_calculate_velocity_components(ox, oy, unclamped_prex, unclamped_prey, &vel_x, &vel_y);
 
-	nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+	nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
 	if (nearest) {
-	    barrier_clamp_to_barrier(nearest, dir, x, y);
+	    int velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+	    Bool threshold_exceeded = (nearest->velocity != 0) &&
+				      (velocity > nearest->velocity);
+
+	    if (!nearest->lastHit) {
+		/* This is the start of a new barrier event */
+		nearest->barrierEventID++;
+	    }
+
+	    if ((!threshold_exceeded || nearest->lastHit) &&
+		(nearest->barrierEventID != nearest->releaseEventID)) {
+		barrier_clamp_to_barrier(nearest, dir, x, y);
+		nearest->hit = TRUE;
+	    }
+
+	    QueueBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
 
 	    if (barrier_is_vertical(nearest)) {
 		dir &= ~(BarrierNegativeX | BarrierPositiveX);
@@ -1265,11 +1422,31 @@
 		oy = *y;
 	    }
 
-	    nearest = barrier_find_nearest(cs, dir, ox, oy, *x, *y);
+	    nearest = barrier_find_nearest(cs, dir, ox, oy, unclamped_prex, unclamped_prey);
 	    if (nearest) {
-		barrier_clamp_to_barrier(nearest, dir, x, y);
+		velocity = barrier_is_vertical(nearest) ? vel_x : vel_y;
+		threshold_exceeded = (nearest->velocity != 0) &&
+				     (velocity > nearest->velocity);
+
+		if (!nearest->lastHit) {
+		    /* This is the start of a new barrier event */
+		    nearest->barrierEventID++;
+		}
+
+		if ((!threshold_exceeded || nearest->lastHit) &&
+		    (nearest->barrierEventID != nearest->releaseEventID)) {
+		    barrier_clamp_to_barrier(nearest, dir, x, y);
+		    nearest->hit = TRUE;
+		}
+
+		QueueBarrierEvent(cs, nearest, *x, *y, velocity, threshold_exceeded);
 	    }
 	}
+
+	list_for_each_entry(c, &cs->barriers, entry) {
+	    c->barrier.lastHit = c->barrier.hit;
+	    c->barrier.hit = FALSE;
+	}
     }
 
     if (cs->ConstrainCursorHarder) {
@@ -1284,15 +1461,45 @@
 			   xXFixesCreatePointerBarrierReq *stuff)
 {
     CursorScreenPtr cs = GetCursorScreen(screen);
-    struct PointerBarrierClient *ret = malloc(sizeof(*ret));
+    struct PointerBarrierClient *ret = calloc(sizeof(*ret), 1);
 
     if (ret) {
 	ret->screen = screen;
+	ret->barrier.barrier = stuff->barrier;
 	ret->barrier.x1 = min(stuff->x1, stuff->x2);
 	ret->barrier.x2 = max(stuff->x1, stuff->x2);
 	ret->barrier.y1 = min(stuff->y1, stuff->y2);
 	ret->barrier.y2 = max(stuff->y1, stuff->y2);
 	ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = 0;
+	ret->barrier.barrierEventID = 0;
+	if (barrier_is_horizontal(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
+	if (barrier_is_vertical(&ret->barrier))
+	    ret->barrier.directions &= ~(BarrierPositiveY | BarrierNegativeY);
+	list_add(&ret->entry, &cs->barriers);
+    }
+
+    return ret;
+}
+
+static struct PointerBarrierClient *
+CreatePointerBarrierVelocityClient(ScreenPtr screen, ClientPtr client,
+			   xXFixesCreatePointerBarrierVelocityReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierClient *ret = calloc(sizeof(*ret), 1);
+
+    if (ret) {
+	ret->screen = screen;
+	ret->barrier.barrier = stuff->barrier;
+	ret->barrier.x1 = min(stuff->x1, stuff->x2);
+	ret->barrier.x2 = max(stuff->x1, stuff->x2);
+	ret->barrier.y1 = min(stuff->y1, stuff->y2);
+	ret->barrier.y2 = max(stuff->y1, stuff->y2);
+	ret->barrier.directions = stuff->directions & 0x0f;
+	ret->barrier.velocity = stuff->velocity;
+	ret->barrier.barrierEventID = 0;
 	if (barrier_is_horizontal(&ret->barrier))
 	    ret->barrier.directions &= ~(BarrierPositiveX | BarrierNegativeX);
 	if (barrier_is_vertical(&ret->barrier))
@@ -1365,6 +1572,69 @@
     return ProcXFixesVector[stuff->xfixesReqType](client);
 }
 
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierClient *barrier;
+    struct PointerBarrier b;
+    REQUEST (xXFixesCreatePointerBarrierVelocityReq);
+
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierVelocityReq);
+    LEGAL_NEW_RESOURCE(stuff->barrier, client);
+
+    err = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    /* This sure does need fixing. */
+    if (stuff->num_devices)
+	return BadImplementation;
+
+    b.x1 = stuff->x1;
+    b.x2 = stuff->x2;
+    b.y1 = stuff->y1;
+    b.y2 = stuff->y2;
+
+    if (!barrier_is_horizontal(&b) && !barrier_is_vertical(&b))
+	return BadValue;
+
+    /* no 0-sized barriers */
+    if (barrier_is_horizontal(&b) && barrier_is_vertical(&b))
+	return BadValue;
+
+    if (!(barrier = CreatePointerBarrierVelocityClient(pWin->drawable.pScreen,
+						       client, stuff)))
+	return BadAlloc;
+
+    if (!AddResource(stuff->barrier, PointerBarrierType, &barrier->barrier))
+	return BadAlloc;
+
+    return Success;
+}
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesCreatePointerBarrierVelocityReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesCreatePointerBarrierReq);
+    swapl(&stuff->barrier, n);
+    swapl(&stuff->window, n);
+    swaps(&stuff->x1, n);
+    swaps(&stuff->y1, n);
+    swaps(&stuff->x2, n);
+    swaps(&stuff->y2, n);
+    swapl(&stuff->directions, n);
+    swapl(&stuff->velocity, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 static int
 CursorFreeBarrier(void *data, XID id)
 {
@@ -1421,6 +1691,118 @@
     return ProcXFixesVector[stuff->xfixesReqType](client);
 }
 
+static int
+CursorFreeBarrierClient(void *data, XID id)
+{
+    PointerBarrierEventClientPtr client = data, c;
+    ScreenPtr screen = client->screen;
+    CursorScreenPtr cs = GetCursorScreen(screen);
+
+    /* find and unlink from the screen private */
+    list_for_each_entry(c, &cs->barrierClients, entry) {
+	if (c == client) {
+	    list_del(&c->entry);
+	    break;
+	}
+    }
+
+    free(client);
+    return Success;
+}
+
+static struct PointerBarrierEventClient *
+CreatePointerBarrierEventClient(ScreenPtr screen, ClientPtr client,
+				   xXFixesSelectBarrierInputReq *stuff)
+{
+    CursorScreenPtr cs = GetCursorScreen(screen);
+    struct PointerBarrierEventClient *ret = malloc(sizeof(*ret));
+
+    if (ret) {
+	ret->screen = screen;
+	ret->client = client;
+	ret->eventMask = stuff->eventMask;
+	ret->window = stuff->window;
+	ret->resource = FakeClientID (client->index);
+      list_add(&ret->entry, &cs->barrierClients);
+    }
+
+    return ret;
+}
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    int err;
+    WindowPtr pWin;
+    struct PointerBarrierEventClient *eventClient;
+    REQUEST (xXFixesSelectBarrierInputReq);
+
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+
+    err = dixLookupWindow(&pWin	, stuff->window, client, DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->window;
+	return err;
+    }
+
+    if (!(eventClient = CreatePointerBarrierEventClient(pWin->drawable.pScreen,
+							client,
+							stuff)))
+      return BadAlloc;
+
+    if (!AddResource (eventClient->resource, PointerBarrierClientType, eventClient))
+      return BadAlloc;
+
+    return Success;
+}
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesSelectBarrierInputReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesSelectBarrierInputReq);
+    swapl(&stuff->window, n);
+    swapl(&stuff->eventMask, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    int err;
+    struct PointerBarrier *barrier;
+    REQUEST (xXFixesBarrierReleasePointerReq);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+
+    err = dixLookupResourceByType((void **)&barrier, stuff->barrier,
+				  PointerBarrierType, client,
+				  DixReadAccess);
+    if (err != Success) {
+	client->errorValue = stuff->barrier;
+	return err;
+    }
+
+    barrier->releaseEventID = stuff->event_id;
+
+    return Success;
+}
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client)
+{
+    int n;
+    REQUEST(xXFixesBarrierReleasePointerReq);
+
+    swaps(&stuff->length, n);
+    REQUEST_SIZE_MATCH(xXFixesBarrierReleasePointerReq);
+    swapl(&stuff->barrier, n);
+    swapl(&stuff->event_id, n);
+    return ProcXFixesVector[stuff->xfixesReqType](client);
+}
+
 Bool
 XFixesCursorInit (void)
 {
@@ -1441,6 +1823,7 @@
 	if (!cs)
 	    return FALSE;
 	list_init(&cs->barriers);
+	list_init(&cs->barrierClients);
 	Wrap (cs, pScreen, CloseScreen, CursorCloseScreen);
 	Wrap (cs, pScreen, DisplayCursor, CursorDisplayCursor);
 	Wrap (cs, pScreen, ConstrainCursorHarder, CursorConstrainCursorHarder);
@@ -1455,8 +1838,10 @@
 					     "XFixesCursorWindow");
     PointerBarrierType = CreateNewResourceType(CursorFreeBarrier,
 					      "XFixesPointerBarrier");
+    PointerBarrierClientType = CreateNewResourceType(CursorFreeBarrierClient,
+						     "XFixesPointerBarrierClient");
 
     return CursorClientType && CursorHideCountType && CursorWindowType &&
-	   PointerBarrierType;
+	   PointerBarrierType && PointerBarrierClientType;
 }
 
Index: xorg-server/xfixes/xfixes.c
===================================================================
--- xorg-server.orig/xfixes/xfixes.c	2012-03-07 22:24:45.592697117 +1100
+++ xorg-server/xfixes/xfixes.c	2012-03-08 07:40:35.480111388 +1100
@@ -100,6 +100,7 @@
     X_XFixesExpandRegion,	    /* Version 3 */
     X_XFixesShowCursor,		    /* Version 4 */
     X_XFixesDestroyPointerBarrier,  /* Version 5 */
+    X_XFixesBarrierReleasePointer, /* Version 6 */
 };
 
 #define NUM_VERSION_REQUESTS	(sizeof (version_requests) / sizeof (version_requests[0]))
@@ -143,6 +144,10 @@
 /*************** Version 5 ****************/
     ProcXFixesCreatePointerBarrier,
     ProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+    ProcXFixesCreatePointerBarrierVelocity,
+    ProcXFixesSelectBarrierInput,
+    ProcXFixesBarrierReleasePointer,
 };
 
 static int
@@ -209,6 +214,10 @@
 /*************** Version 5 ****************/
     SProcXFixesCreatePointerBarrier,
     SProcXFixesDestroyPointerBarrier,
+/*************** Version 6 ****************/
+    SProcXFixesCreatePointerBarrierVelocity,
+    SProcXFixesSelectBarrierInput,
+    SProcXFixesBarrierReleasePointer,
 };
 
 static int
Index: xorg-server/xfixes/xfixes.h
===================================================================
--- xorg-server.orig/xfixes/xfixes.h	2012-03-07 22:24:45.608697118 +1100
+++ xorg-server/xfixes/xfixes.h	2012-03-08 07:40:35.480111388 +1100
@@ -28,6 +28,7 @@
 #define _XFIXES_H_
 
 #include "resource.h"
+#include "list.h"
 
 extern _X_EXPORT RESTYPE RegionResType;
 extern _X_EXPORT RESTYPE PointerBarrierType;
@@ -52,9 +53,25 @@
 extern _X_EXPORT RegionPtr
 XFixesRegionCopy (RegionPtr pRegion);
 
+typedef struct PointerBarrierEventClient *PointerBarrierEventClientPtr;
+
+struct PointerBarrierEventClient {
+    ScreenPtr screen;
+    ClientPtr client;
+    CARD32    eventMask;
+    XID window;
+    XID resource;
+    struct list entry;
+};
+
 struct PointerBarrier {
+    XID    barrier;
     CARD16 x1, x2, y1, y2;
     CARD32 directions;
+    CARD32 velocity;
+    CARD32 barrierEventID;
+    CARD32 releaseEventID;
+    Bool   hit, lastHit;
 };
 
 
Index: xorg-server/xfixes/xfixesint.h
===================================================================
--- xorg-server.orig/xfixes/xfixesint.h	2012-03-07 22:24:45.616697118 +1100
+++ xorg-server/xfixes/xfixesint.h	2012-03-08 07:40:35.480111388 +1100
@@ -59,6 +59,7 @@
 #include "windowstr.h"
 #include "selection.h"
 #include "xfixes.h"
+#include "list.h"
 
 extern int		XFixesEventBase;
 
@@ -293,6 +294,26 @@
 int
 SProcXFixesDestroyPointerBarrier (ClientPtr client);
 
+/* Version 6 */
+
+int
+ProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+SProcXFixesSelectBarrierInput (ClientPtr client);
+
+int
+ProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+SProcXFixesCreatePointerBarrierVelocity (ClientPtr client);
+
+int
+ProcXFixesBarrierReleasePointer (ClientPtr client);
+
+int
+SProcXFixesBarrierReleasePointer (ClientPtr client);
+
 /* Xinerama */
 extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests])(ClientPtr);
 void PanoramiXFixesInit (void);
Index: xorg-server/dix/getevents.c
===================================================================
--- xorg-server.orig/dix/getevents.c	2012-03-07 22:24:45.624697119 +1100
+++ xorg-server/dix/getevents.c	2012-03-08 11:02:31.739464474 +1100
@@ -79,6 +79,12 @@
 InternalEvent* InputEventList = NULL;
 
 /**
+ * xfixes/cursor.c wants the unclamped (x,y) values for velocity
+ * calculation.  Export them here.
+ */
+int unclamped_prex = -1, unclamped_prey = -1;
+
+/**
  * Pick some arbitrary size for Xi motion history.
  */
 int
@@ -903,7 +909,15 @@
     /* miPointerSetPosition takes care of crossing screens for us, as well as
      * clipping to the current screen. Coordinates returned are in desktop
      * coord system */
+    /**
+     * Hack to pass the unclipped values through to the pointer barrier code.
+     * Required (for now) to calculate the velocity.
+     */
+    unclamped_prex = (int)floor(*screenx) - scr->x;
+    unclamped_prey = (int)floor(*screeny) - scr->y;
     scr = miPointerSetPosition(dev, mode, screenx, screeny);
+    unclamped_prex = -1;
+    unclamped_prey = -1;
 
     /* If we were constrained, rescale x/y from the screen coordinates so
      * the device valuators reflect the correct position. For screen
Index: xorg-server/test/gtest/xfixes_barriers.cpp
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/test/gtest/xfixes_barriers.cpp	2012-03-08 07:42:49.188104249 +1100
@@ -0,0 +1,828 @@
+/*
+
+Copyright (c) 2012, Canonical Ltd
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the "Software"),
+to deal in the Software without restriction, including without limitation
+the rights to use, copy, modify, merge, publish, distribute, sublicense,
+and/or sell copies of the Software, and to permit persons to whom the
+Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice (including the next
+paragraph) shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
+*/
+
+#include <iostream>
+#include <sys/time.h>
+#include <unistd.h>
+#include <gtest/gtest.h>
+#include <xorg/gtest/test.h>
+#include <xorg/gtest/environment.h>
+#include <X11/Xlib.h>
+#include <X11/extensions/XTest.h>
+#include <X11/extensions/Xfixes.h>
+
+
+int main (int argc, char **argv)
+{
+    ::testing::InitGoogleTest (&argc, argv);
+    xorg::testing::Environment* environment = new xorg::testing::Environment ();
+    environment->set_conf_file (XORG_DUMMY_CONF);
+    environment->set_server (XORG_BINARY);
+    testing::AddGlobalTestEnvironment (environment);
+    return RUN_ALL_TESTS ();
+}
+
+class BarrierTest : public xorg::testing::Test {
+    public:
+    ::Display *dpy;
+    static XErrorEvent *lastError;
+    int xtest_eventbase;
+    int xtest_errorbase;
+    int fixes_eventbase;
+    int fixes_errorbase;
+
+    void AssertPointerPosition (int expected_x, int expected_y)
+    {
+        int x, y, unused_int;
+        unsigned int unused_uint;
+        Window unused_win;
+
+        XQueryPointer (Display (), DefaultRootWindow (Display ()),
+                       &unused_win, &unused_win, &x, &y,
+                       &unused_int, &unused_int, &unused_uint);
+
+        ASSERT_TRUE (x == expected_x && y == expected_y) <<
+            "Incorrect pointer position: Expected ("<<
+            expected_x<< ", "<<expected_y<<"), got "<<
+            "("<<x<<", "<<y<<")\n";
+    }
+
+    bool WaitForXEvent (int msTimeout = 1000)
+    {
+        fd_set fds;
+        int xfd = ConnectionNumber (Display ());
+        struct timeval tv;
+        int retval;
+
+        FD_ZERO (&fds);
+        FD_SET (xfd, &fds);
+
+        tv.tv_sec = msTimeout / 1000;
+        tv.tv_usec = (msTimeout % 1000) * 1000;
+
+        retval = select (xfd + 1, &fds, NULL, NULL, &tv);
+
+        EXPECT_NE (-1, retval)<<"Error waiting for X event";
+
+        return retval;
+    }
+
+    protected:
+    virtual void SetUp ()
+    {
+        ASSERT_NO_FATAL_FAILURE (xorg::testing::Test::SetUp());
+
+        dpy = Display ();
+        int major = 2, minor = 2;
+        ASSERT_TRUE (XTestQueryExtension (dpy,
+                                          &xtest_eventbase, &xtest_errorbase,
+                                          &major, &minor));
+        ASSERT_EQ (2, major);
+        ASSERT_TRUE (minor >= 2);
+
+        major = 6;
+        minor = 0;
+        XFixesQueryVersion (dpy, &major, &minor);
+        ASSERT_EQ (6, major);
+        ASSERT_TRUE (minor >= 0);
+
+        ASSERT_TRUE (XFixesQueryExtension (dpy,
+                                           &fixes_eventbase, &fixes_errorbase));
+
+        lastError = new XErrorEvent;
+        XSetErrorHandler (ErrorHandler);
+    }
+
+    private:
+    static int ErrorHandler (::Display *dpy, XErrorEvent *error)
+    {
+        memcpy (lastError, error, sizeof (*lastError));
+        return 0;
+    }
+};
+
+XErrorEvent *BarrierTest::lastError = NULL;
+
+TEST_F (BarrierTest, CreateVerticalBarrierSucceeds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 0,
+                                          100, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateHorizontalBarrierSucceds)
+{
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                          100, 100,
+                                          200, 100,
+                                          0,
+                                          0, NULL);
+    ASSERT_NE(None, barrier);
+}
+
+TEST_F (BarrierTest, CreateNonAxisAlignedBarrierFails)
+{
+    XFixesCreatePointerBarrier (dpy, DefaultRootWindow(dpy),
+                                0, 0,
+                                100, 100,
+                                0,
+                                0, NULL);
+    XSync (Display (), false);
+    ASSERT_EQ(BadValue, lastError->error_code);
+}
+
+TEST_F (BarrierTest, VerticalBidirectionalBarrierBlocksRelativeMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y));
+}
+
+TEST_F (BarrierTest, VerticalPositiveXBarrierBlocksMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierPositiveX, 0, NULL);
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve X direction should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = 0, y = 100, dx = 200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve X direction should ignore barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, VerticalNegativeXBarrierBlocksMotion)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierNegativeX,
+                                0, NULL);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve X direction should ignore barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 0, y = 100, dx = 200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve X direction should block on barrier
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBidirectionalBarrierBlocksRelativeMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                0, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should block on barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should block on barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, HorizontalPositiveYBarrierBlocksMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                BarrierPositiveY, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should ignore barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should block on barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, HorizontalNegativeYBarrierBlocksMotion)
+{
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0,   barrier_y,
+                                300, barrier_y,
+                                BarrierNegativeY, 0, NULL);
+
+    int x = 200, y = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in +ve Y direction should block on barrier
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Relative motion in -ve Y direction should ignore barrier
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, DestroyPointerBarrierSucceeds)
+{
+    int barrier_x = 100;
+    PointerBarrier barrier;
+    barrier = XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                          barrier_x, 0,
+                                          barrier_x, 300,
+                                          0, 0, NULL);
+
+    int x = 0, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Check that the barrier exists before we destroy it.
+    int dx = 200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+
+    // Destroy the barrier...
+    XFixesDestroyPointerBarrier (Display (), barrier);
+
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // There should be no barrier to block this.
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, BarrierIgnoresNonsensicalDirections)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                BarrierPositiveY | BarrierNegativeY,
+                                0, NULL);
+
+    int x = 200, y = 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    int barrier_y = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                               0,   barrier_y,
+                               400, barrier_y,
+                               BarrierPositiveX | BarrierNegativeX,
+                               0, NULL);
+
+    x = 100, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = -200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+}
+
+TEST_F (BarrierTest, VerticalBarrierEdges)
+{
+    int barrier_x = 300, barrier_y1 = 300 , barrier_y2 = 500;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, barrier_y1,
+                                barrier_x, barrier_y2,
+                                0, 0, NULL);
+
+    int x = barrier_x + 100, y = barrier_y1 - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the top of the barrier...
+    int dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x + 100, y = barrier_y1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the top of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x + 100, y = barrier_y2;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the bottom of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x + 100, y = barrier_y2 + 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the bottom of the barrier...
+    dx = -200, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBarrierEdges)
+{
+    int barrier_x1 = 200, barrier_x2 = 500, barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x1, barrier_y,
+                                barrier_x2, barrier_y,
+                                0, 0, NULL);
+
+    int x = barrier_x1 - 1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the left edge of the barrier...
+    int dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the top of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, barrier_y - 1));
+
+    x = barrier_x2, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should hit the bottom of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = barrier_x2 + 1, y = barrier_y - 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    // Motion should take us past the bottom of the barrier...
+    dx = 0, dy = 200;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, CornerBlocksMotion)
+{
+    int corner_x, corner_y;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                corner_x, corner_y,
+                                corner_x, corner_y + 300,
+                                0, 0, NULL);
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                corner_x, corner_y,
+                                corner_x + 300, corner_y,
+                                0, 0, NULL);
+
+    int x = corner_x + 100, y = corner_y + 100;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    XTestFakeRelativeMotionEvent (Display (), -200, -200, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (corner_x, corner_y));
+}
+
+TEST_F (BarrierTest, VerticalBarrierWithAdjacentStart)
+{
+    int barrier_x = 350;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 100,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    int x = barrier_x, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = -10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x, y + dy));
+
+    x = barrier_x, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = barrier_x - 1, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (barrier_x - 1, y + dy));
+
+    x = barrier_x - 1, y = 200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = -10, dy = 0;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, HorizontalBarrierWithAdjacentStart)
+{
+    int barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                100, barrier_y,
+                                400, barrier_y,
+                                0, 0, NULL);
+
+    int x = 240, y = barrier_y;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    int dx = 0, dy = -10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y));
+
+    x = 240, y = barrier_y;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = 10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+
+    x = 240, y = barrier_y - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = 10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, barrier_y - 1));
+
+    x = 240, y = barrier_y - 1;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    dx = 0, dy = -10;
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x + dx, y + dy));
+}
+
+TEST_F (BarrierTest, BarrierNotifyEventFires)
+{
+    int barrier_y = 300;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                100, barrier_y,
+                                400, barrier_y,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 240, y = barrier_y + 50;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    XTestFakeRelativeMotionEvent (Display (), 0, -100, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                return;
+        }
+    }
+    FAIL () << "Failed to recieve BarrierNotify event";
+}
+
+TEST_F (BarrierTest, RecieveOneNotifyEventPerHit)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* Generate 5 barrier events */
+    for (int i = 0; i < 5; ++i) {
+        XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    }
+
+    int barrierEventCount = 0;
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                barrierEventCount++;
+                break;
+        }
+    }
+    ASSERT_EQ (5, barrierEventCount);
+}
+
+TEST_F (BarrierTest, BarrierEventHasNonZeroVelocity)
+{
+    int barrier_x = 100;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 200, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ScreenEdgeVerticalBarrierEventHasNonZeroVelocity)
+{
+    int barrier_x = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 100, y = 100, dx = -200, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ScreenEdgeHorizontalBarrierEventHasNonZeroVelocity)
+{
+    int barrier_y = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                0, barrier_y,
+                                300, barrier_y,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 100, y = 100, dx = 0, dy = -200;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* One relative event to ensure the server has a non-zero
+     * last-event-time */
+    XTestFakeRelativeMotionEvent (Display (), 10, 10, 0);
+    /* Run the pointer into the barrier */
+    XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                XFixesBarrierNotifyEvent *notify = (XFixesBarrierNotifyEvent *)&e;
+                ASSERT_LT (0, notify->velocity);
+                return;
+        }
+    }
+    FAIL () << "Failed to receive barrier event";
+}
+
+TEST_F (BarrierTest, ReceiveOneBarrierEventPerHitOnScreenEdge)
+{
+    int barrier_x = 0;
+    XFixesCreatePointerBarrier (Display (), DefaultRootWindow (Display ()),
+                                barrier_x, 0,
+                                barrier_x, 300,
+                                0, 0, NULL);
+
+    XFixesSelectBarrierInput (Display (), DefaultRootWindow (Display ()),
+                              XFixesBarrierHitNotifyMask);
+
+    int x = 20, y = 100, dx = -40, dy = 0;
+    XTestFakeMotionEvent (Display (), DefaultScreen (Display ()),
+                          x, y, 0);
+    ASSERT_NO_FATAL_FAILURE (AssertPointerPosition (x, y));
+
+    /* Generate 5 barrier events */
+    for (int i = 0; i < 5; ++i) {
+        XTestFakeRelativeMotionEvent (Display (), dx, dy, 0);
+    }
+
+    int barrierEventCount = 0;
+    XFlush (Display ());
+    ASSERT_TRUE (WaitForXEvent ())<<"Timed out waiting to receive X event";
+    while (XPending (Display ())) {
+        XEvent e;
+        XNextEvent (Display (), &e);
+        switch (e.xany.type - fixes_eventbase) {
+            case XFixesBarrierNotify:
+                barrierEventCount++;
+                break;
+        }
+    }
+    ASSERT_EQ (5, barrierEventCount);
+}
Index: xorg-server/configure.ac
===================================================================
--- xorg-server.orig/configure.ac	2012-03-08 07:40:35.416111392 +1100
+++ xorg-server/configure.ac	2012-03-08 11:02:31.783464472 +1100
@@ -2155,6 +2155,25 @@
 
 AC_CONFIG_COMMANDS([sdksyms], [touch hw/xfree86/sdksyms.dep])
 
+AC_PROG_CXX
+
+PKG_CHECK_MODULES(XORG_GTEST, xorg-gtest,
+        [have_xorg_gtest="yes"],
+        [AC_MSG_WARN([xorg-gtest not installed, tests will not be built])])
+AM_CONDITIONAL([HAVE_XORG_GTEST], [test "x$have_xorg_gtest" = xyes])
+AC_SUBST([XORG_GTEST_CFLAGS])
+AC_SUBST([XORG_GTEST_LIBS])
+
+PKG_CHECK_MODULES([XFIXES], xfixes, [have_xfixes="yes"], [have_xfixes="no"])
+AM_CONDITIONAL([HAVE_XFIXES], [test "x$have_xfixes" = xyes])
+AC_SUBST([XFIXES_CFLAGS])
+AC_SUBST([XFIXES_LIBS])
+
+PKG_CHECK_MODULES([XTEST], xtst, [have_xtest="yes"], [have_xtest="no"])
+AM_CONDITIONAL([HAVE_XTEST], [test "x$have_xtest" = xyes])
+AC_SUBST([XTEST_CFLAGS])
+AC_SUBST([XTEST_LIBS])
+
 AC_OUTPUT([
 Makefile
 glx/Makefile
@@ -2254,6 +2273,7 @@
 hw/kdrive/src/Makefile
 test/Makefile
 test/xi2/Makefile
+test/gtest/Makefile
 xserver.ent
 xorg-server.pc
 ])
Index: xorg-server/test/gtest/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/test/gtest/Makefile.am	2012-03-08 07:40:35.488111388 +1100
@@ -0,0 +1,27 @@
+check_PROGRAMS = xfixes_barriers
+check_DATA = dummy.conf
+
+TESTS=xfixes_barriers
+
+GTEST_SRC_DIR = /usr/src/gtest
+GTEST_SOURCES = $(GTEST_SRC_DIR)/src/gtest-all.cc
+
+xfixes_barriers_CXXFLAGS = $(AM_CXXFLAGS) \
+	-I$(GTEST_SRC_DIR) \
+	$(XORG_GTEST_CFLAGS) \
+	$(XTEST_CFLAGS) \
+	$(XFIXES_CFLAGS) \
+	-DXORG_BINARY=\"$(top_builddir)/hw/xfree86/Xorg\" \
+	-DXORG_DUMMY_CONF=\"$(abs_srcdir)/dummy.conf\"
+
+xfixes_barriers_LDADD = \
+	$(XFIXES_LIBS) \
+	$(XTEST_LIBS) \
+	$(XORG_GTEST_LIBS) \
+	-lpthread
+
+xfixes_barriers_SOURCES = \
+	xfixes_barriers.cpp
+
+nodist_xfixes_barriers_SOURCES = \
+	$(GTEST_SOURCES)
Index: xorg-server/test/Makefile.am
===================================================================
--- xorg-server.orig/test/Makefile.am	2012-03-07 22:24:45.684697122 +1100
+++ xorg-server/test/Makefile.am	2012-03-08 07:40:35.488111388 +1100
@@ -1,5 +1,10 @@
 if ENABLE_UNIT_TESTS
 SUBDIRS= . xi2
+
+if HAVE_XORG_GTEST
+SUBDIRS+= gtest
+endif
+
 noinst_PROGRAMS = xkb input xtest list misc fixes xfree86 touch
 check_LTLIBRARIES = libxservertest.la
 
Index: xorg-server/test/gtest/dummy.conf
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ xorg-server/test/gtest/dummy.conf	2012-03-08 07:40:35.488111388 +1100
@@ -0,0 +1,4 @@
+Section "Device"
+    Identifier "Dummy video device"
+    Driver "dummy"
+EndSection
Index: xorg-server/dix/dixutils.c
===================================================================
--- xorg-server.orig/dix/dixutils.c	2012-03-08 07:40:35.392111393 +1100
+++ xorg-server/dix/dixutils.c	2012-03-08 07:40:35.488111388 +1100
@@ -537,7 +537,7 @@
 	{
 	    /* remove q from the list */
 	    *p = q->next;    /* don't fetch until after func called */
-	    free(q);
+	    (*q->destroyProc) (q);
 	}
 	else
 	{
@@ -560,7 +560,7 @@
 	    (void) (*q->function) (q->client, q->closure);
 	    /* remove q from the list */
 	    *p = q->next;    /* don't fetch until after func called */
-	    free(q);
+	    (*q->destroyProc) (q);
 	}
 	else
 	{
@@ -570,6 +570,12 @@
     workQueueLast = p;
 }
 
+static void
+FreeWorkQueueItem (WorkQueuePtr this)
+{
+    free(this);
+}
+
 Bool
 QueueWorkProc (
     Bool (*function)(ClientPtr /* pClient */, pointer /* closure */),
@@ -583,12 +589,22 @@
     q->function = function;
     q->client = client;
     q->closure = closure;
+    q->destroyProc = FreeWorkQueueItem;
     q->next = NULL;
     *workQueueLast = q;
     workQueueLast = &q->next;
     return TRUE;
 }
 
+Bool
+QueueWorkItem (WorkQueuePtr item)
+{
+    item->next = NULL;
+    *workQueueLast = item;
+    workQueueLast = &item->next;
+    return TRUE;
+}
+
 /*
  * Manage a queue of sleeping clients, awakening them
  * when requested, by using the OS functions IgnoreClient
Index: xorg-server/include/dixstruct.h
===================================================================
--- xorg-server.orig/include/dixstruct.h	2012-03-07 22:24:45.552697115 +1100
+++ xorg-server/include/dixstruct.h	2012-03-08 07:40:35.492111388 +1100
@@ -153,6 +153,9 @@
 );
     ClientPtr   client;
     pointer     closure;
+    void       (*destroyProc) (
+                struct _WorkQueue * /* this */
+);
 }           WorkQueueRec;
 
 extern _X_EXPORT TimeStamp currentTime;
Index: xorg-server/include/dix.h
===================================================================
--- xorg-server.orig/include/dix.h	2012-03-07 22:24:45.568697116 +1100
+++ xorg-server/include/dix.h	2012-03-08 07:40:35.492111388 +1100
@@ -266,6 +266,8 @@
     pointer /*closure*/
 );
 
+extern _X_EXPORT Bool QueueWorkItem(WorkQueuePtr item);
+
 typedef Bool (* ClientSleepProcPtr)(
     ClientPtr /*client*/,
     pointer /*closure*/);
